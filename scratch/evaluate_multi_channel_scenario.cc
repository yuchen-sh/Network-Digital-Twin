/*
 * Copyright (c) 2015-2020 IMDEA Networks Institute
 * Author: Hany Assasa <hany.assasa@gmail.com>
 */
#include "ns3/applications-module.h"
#include "ns3/core-module.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/internet-module.h"
#include "ns3/mobility-module.h"
#include "ns3/network-module.h"
#include "ns3/spectrum-module.h"
#include "ns3/wifi-module.h"
#include "common-functions.h"
#include <iomanip>
#include <sstream>

/**
 * Simulation Objective:
 * This script is used to validate and evaluate the performance and behaviour of the IEEE 802.11ay model for Multi-AP
 * deployment over Q-D channel model. Each network in this scenario can use a different channel configuration as specified
 * in IEEE 802.11ay. In particular, we look into the following cases:
 * 1. Co-channel interference i.e. the two networks use the same frequency channel.
 * 2. Adjacent channel interference i.e. the two networks use two seperate chanenls
 * but the transmit masks of these two channels partially overlap.
 * 3. No overlap between the transmit masks of the channels.
 * 4. One network is using channel bonding and the other network uses a single frequency channel.
 * However, the single channel is contained in the bonded channel of the first network.
 *
 * DMG APs and DMG STAs use a parametric codebook generated by our IEEE 802.11ay
 * Codebook Generator in MATLAB. Each device uses an URA antenna array of 2x8 Elements. The channel model is generated
 * by our Q-D Realization software.
 *
 * Network Topology:
 * The scenario consists of two parallel links. The distance between the two link is dependent on the
 * Q-D realization files utilized for this simulation. The Q-D files contain multiple traces where
 * each trace correspond to a particular seperation distance between the two links.
 * TraceIndex = 0 corresponds to a seperation distance of 0.5 m. The
 *
 *
 *          DMG AP_1  (0, +1)               DMG AP_2  (+1, +1)
 *
 *                 ^                               ^
 *                 |                               |
 *                 |       <--- distance --->      |
 *                 |                               |
 *
 *          DMG STA_1 (0, -1)               DMG STA_2 (+1, -1)
 *
 *
 * Simulation Description:
 * Once a DMG STA is associated with its corresponding DMG PCP/ACP, it generates multiple TCP flows towards that DMG PCP/AP.
 * We use DMG Error Model generated using MATLAB WLAN Toolbox.
 *
 * Running Simulation:
 * To run this script with default parameters (UDP protocol with onoff application), type the following command:
 * ./waf --run "evaluate_multi_channel_scenario"
 *
 * To run with TCP protocol and bulk application using CBT RAA algorithm, type the following command:
 * ./waf --run "evaluate_multi_channel_scenario --applicationType=bulk --socketType=ns3::TcpSocketFactory --csv=false --raa=CbtraaDmg"
 *
 * To enable channel bonding for the two links with run with TCP protocol and bulk application using CBT RAA algorithm while setting ch, type the following command:
 * ./waf --run "evaluate_multi_channel_scenario --applicationType=bulk --socketType=ns3::TcpSocketFactory --csv=false --raa=CbtraaDmg --network1Channel=9 --network2Channel=13"
 *
 * ./waf --run "evaluate_multi_channel_scenario --applicationType=onoff --socketType=ns3::UdpSocketFactory --csv=false --network1Channel=9 --dataRate=16Gbps --phyMode=EDMG_SC_MCS21 --qdChannelFolder=MultiChannelScenarioSingleLink --twoNetworks=false --pcap=1 --snapshotLength=120"
 *
 * Simulation Output:
 */

NS_LOG_COMPONENT_DEFINE ("EvaluateMultiChannelScenario");

using namespace ns3;
using namespace std;

/* Tracing */
typedef std::map<Mac48Address, uint32_t> MAP_MAC2ID;
typedef MAP_MAC2ID::iterator MAP_MAC2ID_I;
MAP_MAC2ID map_Mac2ID;
Ptr<QdPropagationEngine> qdPropagationEngine; /* Q-D Propagation Engine. */

/** Simulation Arguments **/
string applicationType = "onoff";             /* Type of the Tx application */
string socketType = "ns3::UdpSocketFactory";  /* Socket Type (TCP/UDP) */
uint32_t packetSize = 1448;                   /* Application payload size in bytes. */
string dataRate = "300Mbps";                  /* Application data rate. */
string tcpVariant = "NewReno";                /* TCP Variant Type. */
uint32_t maxPackets = 0;                      /* Maximum Number of Packets */
string msduAggSize = "max";                   /* The maximum aggregation size for A-MSDU in Bytes. */
string mpduAggSize = "max";                   /* The maximum aggregation size for A-MPDU in Bytes. */
double simulationTime = 10;                   /* Simulation time in seconds. */
bool csv = true;                              /* Enable CSV output. */
bool enableJitter = true;                     /* Enable Beacon Interval Jitter to randomize Beacon Interval start time. */
string beaconJitter = "ns3::UniformRandomVariable[Min=0|Max=10]";

/**  Applications **/
CommunicationPairList communicationPairList;  /* List of communicating devices. */

void
CalculateThroughput (void)
{
  double totalThr = 0;
  double thr;
  if (!csv)
    {
      string duration = to_string_with_precision<double> (Simulator::Now ().GetSeconds () - 0.1, 1)
                      + " - " + to_string_with_precision<double> (Simulator::Now ().GetSeconds (), 1);
      std::cout << std::left << std::setw (12) << duration;
      for (CommunicationPairList_I it = communicationPairList.begin (); it != communicationPairList.end (); it++)
        {
          thr = CalculateSingleStreamThroughput (it->second.packetSink, it->second.totalRx, it->second.throughput);
          totalThr += thr;
          std::cout << std::left << std::setw (12) << thr;
        }
      std::cout << std::left << std::setw (12) << totalThr
                << std::left << std::setw (12) << qdPropagationEngine->GetCurrentTraceIndex () << std::endl;
    }
  else
    {
      std::cout << to_string_with_precision<double> (Simulator::Now ().GetSeconds (), 1);
      for (CommunicationPairList_I it = communicationPairList.begin (); it != communicationPairList.end (); it++)
        {
          thr = CalculateSingleStreamThroughput (it->second.packetSink, it->second.totalRx, it->second.throughput);
          totalThr += thr;
          std::cout << "," << thr;
        }
      std::cout << "," << totalThr << std::endl;
    }
  Simulator::Schedule (MilliSeconds (100), &CalculateThroughput);
}

Ptr<WifiNetDevice>
CreateAccessPoint (Ptr<Node> apNode, Ssid ssid,
                   DmgWifiHelper &wifi, SpectrumDmgWifiPhyHelper &wifiPhy)
{
  DmgWifiMacHelper wifiMac = DmgWifiMacHelper::Default ();

  wifiMac.SetType ("ns3::DmgApWifiMac",
                   "Ssid", SsidValue (ssid),
                   "BeaconInterval", TimeValue (MicroSeconds (102400)),
                   "BE_MaxAmpduSize", StringValue (mpduAggSize),
                   "BE_MaxAmsduSize", StringValue (msduAggSize),
                   "SSSlotsPerABFT", UintegerValue (8), "SSFramesPerSlot", UintegerValue (16),
                   "EnableBeaconJitter", BooleanValue (enableJitter),
                   "EDMGSupported", BooleanValue (true));

  if (enableJitter)
    {
      wifiMac.SetAttrbiute ("BeaconJitter", StringValue (beaconJitter));
    }

  NetDeviceContainer apDevice = wifi.Install (wifiPhy, wifiMac, apNode, false);

  return (StaticCast<WifiNetDevice> (apDevice.Get (0)));
}

void
SLSCompleted (Ptr<OutputStreamWrapper> stream,  Ptr<SLS_PARAMETERS> parameters, SlsCompletionAttrbitutes attributes)
{
  *stream->GetStream () << parameters->srcNodeID + 1 << "," << map_Mac2ID[attributes.peerStation] + 1 << ","
                        << qdPropagationEngine->GetCurrentTraceIndex () << ","
                        << uint16_t (attributes.sectorID) << "," << uint16_t (attributes.antennaID)  << ","
                        << parameters->wifiMac->GetTypeOfStation ()  << ","
                        << map_Mac2ID[parameters->wifiMac->GetBssid ()] + 1  << ","
                        << Simulator::Now ().GetSeconds () << std::endl;

  if (!csv)
    {
      std::cout << "DMG STA " << parameters->wifiMac->GetAddress ()
                << " completed SLS phase with DMG STA " << attributes.peerStation << std::endl;
      std::cout << "Best Tx Antenna Configuration: AntennaID=" << uint16_t (attributes.antennaID)
                << ", SectorID=" << uint16_t (attributes.sectorID) << std::endl;
    }
}

void
StationAssoicated (Ptr<Node> node, Ptr<DmgWifiMac> staWifiMac, Mac48Address address, uint16_t aid)
{
  if (!csv)
    {
      std::cout << "DMG STA " << staWifiMac->GetAddress () << " associated with DMG PCP/AP " << address
                << ", Association ID (AID) = " << aid << std::endl;
    }
  CommunicationPairList_I it = communicationPairList.find (node->GetId ());
  if (it != communicationPairList.end ())
    {
      it->second.startTime = Simulator::Now ();
      it->second.srcApp->StartApplication ();
    }
  else
    {
      NS_FATAL_ERROR ("Could not find application to run.");
    }
}

void
StationDeassoicated (Ptr<Node> node, Ptr<DmgWifiMac> staWifiMac, Mac48Address address)
{
  if (!csv)
    {
      std::cout << "DMG STA " << staWifiMac->GetAddress () << " deassociated from DMG PCP/AP " << address << std::endl;
    }
  CommunicationPairList_I it = communicationPairList.find (node->GetId ());
  if (it != communicationPairList.end ())
    {
      it->second.srcApp->StopApplication ();
    }
  else
    {
      NS_FATAL_ERROR ("Could not find application to delete.");
    }
}

CommunicationPair
InstallApplications (Ptr<Node> srcNode, Ptr<Node> dstNode, Ipv4Address address)
{
  CommunicationPair commPair;

  /* Install TCP/UDP Transmitter on the source node */
  Address dest (InetSocketAddress (address, 9999));
  ApplicationContainer srcApp;
  if (applicationType == "onoff")
    {
      OnOffHelper src (socketType, dest);
      src.SetAttribute ("MaxPackets", UintegerValue (maxPackets));
      src.SetAttribute ("PacketSize", UintegerValue (packetSize));
      src.SetAttribute ("OnTime", StringValue ("ns3::ConstantRandomVariable[Constant=1e6]"));
      src.SetAttribute ("OffTime", StringValue ("ns3::ConstantRandomVariable[Constant=0]"));
      src.SetAttribute ("DataRate", DataRateValue (DataRate (dataRate)));
      srcApp = src.Install (srcNode);
    }
  else if (applicationType == "bulk")
    {
      BulkSendHelper src (socketType, dest);
      srcApp = src.Install (srcNode);
    }
  srcApp.Start (Seconds (simulationTime + 1));
  srcApp.Stop (Seconds (simulationTime));
  commPair.srcApp = srcApp.Get (0);

  /* Install Simple TCP/UDP Server on the destination node */
  PacketSinkHelper sinkHelper (socketType, InetSocketAddress (Ipv4Address::GetAny (), 9999));
  ApplicationContainer sinkApp = sinkHelper.Install (dstNode);
  commPair.packetSink = StaticCast<PacketSink> (sinkApp.Get (0));
  sinkApp.Start (Seconds (0.0));

  return commPair;
}

NetDeviceContainer
InstallMAC_Layer (Ptr<Node> node, DmgWifiHelper &wifi, SpectrumDmgWifiPhyHelper &wifiPhy, string apName)
{
  DmgWifiMacHelper wifiMac = DmgWifiMacHelper::Default ();
  wifiMac.SetType ("ns3::DmgStaWifiMac",
                   "Ssid", SsidValue (Ssid (apName)), "ActiveProbing", BooleanValue (false),
                   "BE_MaxAmpduSize", StringValue (mpduAggSize),
                   "BE_MaxAmsduSize", StringValue (msduAggSize),
                   "RSSRetryLimit", UintegerValue (32),
                   "RSSBackoff", UintegerValue (1),
                   "EDMGSupported", BooleanValue (true));
  return wifi.Install (wifiPhy, wifiMac, node, false);
}

/*** Beamforming CBAP ***/
uint16_t biThreshold = 10;                                    /* BI Threshold to trigger TXSS TXOP. */
std::map<Mac48Address, uint16_t> biCounter;                   /* Number of beacon intervals that have passed. */

void
DataTransmissionIntervalStarted (Ptr<DmgApWifiMac> apWifiMac, Ptr<DmgStaWifiMac> staWifiMac, Mac48Address address, Time)
{
  if (apWifiMac->GetWifiRemoteStationManager ()->IsAssociated (staWifiMac->GetAddress ()) > 0)
    {
      uint16_t counter = biCounter[address];
      counter++;
      if (counter == biThreshold)
        {
          staWifiMac->Perform_TXSS_TXOP (address);
          counter = 0;
        }
      biCounter[address] = counter;
    }
}

void
MacRxOk (Ptr<DmgWifiMac> WifiMac, Ptr<OutputStreamWrapper> stream,
         WifiMacType type, Mac48Address address, double snrValue)
{
  if (type == WIFI_MAC_QOSDATA)
    {
      *stream->GetStream () << Simulator::Now ().GetNanoSeconds () << ","
                            << address << ","
                            << WifiMac->GetAddress () << ","
                            << snrValue << std::endl;
    }
}

int
main (int argc, char *argv[])
{
  uint32_t bufferSize = 131072;                           /* TCP Send/Receive Buffer Size. */
  string queueSize = "4000p";                             /* Wifi MAC Queue Size. */
  bool frameCapture = false;                              /* Use a frame capture model. */
  double frameCaptureMargin = 10;                         /* Frame capture margin in dB. */
  string phyMode = "EDMG_SC_MCS12";                       /* Type of the Physical Layer. */
  bool normalizeWeights = false;                          /* Whether we normalize the antenna weights vector or not. */
  uint32_t snapshotLength = std::numeric_limits<uint32_t>::max ();       /* The maximum PCAP Snapshot Length */
  string raa = "ConstantRate";                            /* The rate adaptation algorithm used by both STAs and APs. */
  bool twoNetworks = true;                                /* Whether we simulate two networks or single network .*/
  bool verbose = false;                                   /* Print Logging Information. */
  bool pcapTracing = false;                               /* PCAP Tracing is enabled or not. */
  uint32_t traceIndex = 0;                                /* Trace Index in the Q-D file. */
  string arrayConfig = "28";                              /* Phased antenna array configuration. */
  string qdChannelFolder = "MultiChannelScenario";        /* The name of the folder containing the QD-Channel files. */
  uint8_t network1Channel = 1;                            /* The channel number of the first network. */
  uint8_t network2Channel = 2;                            /* The channel number of the second network. */

  /* Command line argument parser setup. */
  CommandLine cmd;
  cmd.AddValue ("applicationType", "Type of the Tx Application: onoff or bulk", applicationType);
  cmd.AddValue ("packetSize", "Application packet size in bytes", packetSize);
  cmd.AddValue ("dataRate", "Application data rate", dataRate);
  cmd.AddValue ("maxPackets", "Maximum number of packets to send", maxPackets);
  cmd.AddValue ("tcpVariant", TCP_VARIANTS_NAMES, tcpVariant);
  cmd.AddValue ("socketType", "Type of the Socket (ns3::TcpSocketFactory, ns3::UdpSocketFactory)", socketType);
  cmd.AddValue ("bufferSize", "TCP Buffer Size (Send/Receive) in Bytes", bufferSize);
  cmd.AddValue ("msduAggSize", "The maximum aggregation size for A-MSDU in Bytes", msduAggSize);
  cmd.AddValue ("mpduAggSize", "The maximum aggregation size for A-MPDU in Bytes", mpduAggSize);
  cmd.AddValue ("queueSize", "The maximum size of the Wifi MAC Queue", queueSize);
  cmd.AddValue ("frameCapture", "Use a frame capture model", frameCapture);
  cmd.AddValue ("frameCaptureMargin", "Frame capture model margin in dB", frameCaptureMargin);
  cmd.AddValue ("raa", "The rate adaptation algorithm (RAA) used by both DMG STAs and DMG APs", raa);
  cmd.AddValue ("phyMode", "802.11ad PHY Mode", phyMode);
  cmd.AddValue ("network1Channel", "The channel number of the first network", network1Channel);
  cmd.AddValue ("network2Channel", "The channel number of the second network", network2Channel);
  cmd.AddValue ("normalizeWeights", "Whether we normalize the antenna weights vector or not", normalizeWeights);
  cmd.AddValue ("enableJitter", "Enable Beacon Interval Jitter to randomize Beacon Interval start time", enableJitter);
  cmd.AddValue ("beaconJitter", "Beacon Jitter value in MicroSeconds", beaconJitter);
  cmd.AddValue ("biThreshold", "BI Threshold to trigger beamforming training", biThreshold);
  cmd.AddValue ("twoNetworks", "Whether we simulate two networks or single network", twoNetworks);
  cmd.AddValue ("verbose", "turn on all WifiNetDevice log components", verbose);
  cmd.AddValue ("simulationTime", "Simulation time in seconds", simulationTime);
  cmd.AddValue ("qdChannelFolder", "The name of the folder containing the QD-Channel files", qdChannelFolder);
  cmd.AddValue ("traceIndex", "The Trace Index in the Q-D file", traceIndex);
  cmd.AddValue ("pcap", "Enable PCAP Tracing", pcapTracing);
  cmd.AddValue ("snapshotLength", "The maximum PCAP Snapshot Length", snapshotLength);
  cmd.AddValue ("arrayConfig", "Antenna array configuration", arrayConfig);
  cmd.AddValue ("csv", "Enable CSV output instead of plain text. This mode will suppress all the messages related statistics and events.", csv);
  cmd.Parse (argc, argv);

  /* Validate A-MSDU and A-MPDU values */
  ValidateFrameAggregationAttributes (msduAggSize, mpduAggSize, WIFI_PHY_STANDARD_80211ay);
  /* Configure RTS/CTS and Fragmentation */
  ConfigureRtsCtsAndFragmenatation ();
  /* Wifi MAC Queue Parameters */
  ChangeQueueSize (queueSize);

  /*** Configure TCP Options ***/
  ConfigureTcpOptions (tcpVariant, packetSize, bufferSize);

  /**** WifiHelper is a meta-helper: it helps creates helpers ****/
  DmgWifiHelper wifi;

  /* Basic setup */
  wifi.SetStandard (WIFI_PHY_STANDARD_80211ay);

  /* Turn on logging */
  if (verbose)
    {
      wifi.EnableLogComponents ();
      LogComponentEnable ("EvaluateQdSpatialSharing", LOG_LEVEL_ALL);
    }

  /**** Set up Channel ****/
  Ptr<MultiModelSpectrumChannel> spectrumChannel = CreateObject<MultiModelSpectrumChannel> ();
  qdPropagationEngine = CreateObject<QdPropagationEngine> ();
  qdPropagationEngine->SetAttribute ("QDModelFolder", StringValue ("DmgFiles/QdChannel/" + qdChannelFolder + "/"));
  Ptr<QdPropagationLossModel> lossModelRaytracing = CreateObject<QdPropagationLossModel> (qdPropagationEngine);
  Ptr<QdPropagationDelayModel> propagationDelayRayTracing = CreateObject<QdPropagationDelayModel> (qdPropagationEngine);
  spectrumChannel->AddSpectrumPropagationLossModel (lossModelRaytracing);
  spectrumChannel->SetPropagationDelayModel (propagationDelayRayTracing);
  qdPropagationEngine->SetAttribute ("StartIndex", UintegerValue (traceIndex));

  /**** Setup physical layer ****/
  SpectrumDmgWifiPhyHelper wifiPhy = SpectrumDmgWifiPhyHelper::Default ();
  wifiPhy.SetChannel (spectrumChannel);
  /* All nodes transmit at 10 dBm == 10 mW, no adaptation */
  wifiPhy.Set ("TxPowerStart", DoubleValue (10.0));
  wifiPhy.Set ("TxPowerEnd", DoubleValue (10.0));
  wifiPhy.Set ("TxPowerLevels", UintegerValue (1));
  if (frameCapture)
    {
      /* Frame Capture Model */
      wifiPhy.Set ("FrameCaptureModel", StringValue ("ns3::SimpleFrameCaptureModel"));
      Config::SetDefault ("ns3::SimpleFrameCaptureModel::Margin", DoubleValue (frameCaptureMargin));
    }
  /* Set the rate adaptation algorithm */
  if (raa == "ConstantRate")
    {
      /* Set default algorithm for all nodes to be constant rate */
      wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager", "DataMode", StringValue (phyMode));
    }
  else
    {
      wifi.SetRemoteStationManager ("ns3::" + raa + "WifiManager");
    }

  /* Creating nodes */
  uint32_t parallelLinks; /* The number of parallel links. */
  if (twoNetworks)
    parallelLinks = 2;
  else
    parallelLinks = 1;

  NodeContainer apWifiNodes;
  apWifiNodes.Create (parallelLinks);

  NodeContainer staWifiNodes;
  staWifiNodes.Create (parallelLinks);

  /* Install DMG PCP/AP(s) and DMG STA(s) */
  NetDeviceContainer apDevices, staDevices;
  for (uint32_t i = 0; i < parallelLinks; i++)
    {
      /* Set operating channel */
      EDMG_CHANNEL_CONFIG config ;
      if (i == 0)
        {
          config = FindChannelConfiguration (network1Channel);
        }
      else
        {
          config = FindChannelConfiguration (network2Channel);
        }
      wifiPhy.Set ("ChannelNumber", UintegerValue (config.chNumber));
      wifiPhy.Set ("PrimaryChannelNumber", UintegerValue (config.primayChannel));
      apDevices.Add (CreateAccessPoint (apWifiNodes.Get (i), Ssid ("AP" + std::to_string (i)), wifi, wifiPhy));
      staDevices.Add (InstallMAC_Layer (staWifiNodes.Get (i), wifi, wifiPhy, "AP" + std::to_string (i)));
    }

  /** Install Codebooks **/

  /* Set Parametric Codebook for all the DMG PCPs/APs */
  CodebookParametricHelper codebookHelper;
  codebookHelper.SetCodebookParameters ("NormalizeWeights", BooleanValue (normalizeWeights),
                                        "FileName", StringValue ("DmgFiles/Codebook/CODEBOOK_URA_AP_" + arrayConfig + "x.txt"));
  codebookHelper.Install (apDevices);

  /* Set Parametric Codebook for all the DMG STAs */
  codebookHelper.SetCodebookParameters ("NormalizeWeights", BooleanValue (normalizeWeights),
                                        "FileName", StringValue ("DmgFiles/Codebook/CODEBOOK_URA_STA_" + arrayConfig + "x.txt"));
  codebookHelper.Install (staDevices);

  /* Setting mobility model */
  MobilityHelper mobility;
  mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
  mobility.Install (apWifiNodes);
  mobility.Install (staWifiNodes);

  /* Internet stack*/
  InternetStackHelper stack;
  stack.Install (apWifiNodes);
  stack.Install (staWifiNodes);

  Ipv4AddressHelper address;
  address.SetBase ("10.0.0.0", "255.255.255.0");
  Ipv4InterfaceContainer apInterfaces;
  apInterfaces = address.Assign (apDevices);
  address.Assign (staDevices);

  /* We do not want any ARP packets */
  PopulateArpCache ();

  /** Install Applications **/
  /* DMG STA -->  DMG AP */
  for (uint32_t i = 0; i < parallelLinks; i++)
    {
      communicationPairList[staWifiNodes.Get (i)->GetId ()] = InstallApplications (staWifiNodes.Get (i), apWifiNodes.Get (i),
                                                                                   apInterfaces.GetAddress (i));
    }

  /* MAP MAC Addresses to NodeIDs */
  NetDeviceContainer devices;
  Ptr<WifiNetDevice> netDevice;
  devices.Add (apDevices);
  devices.Add (staDevices);
  for (uint32_t i = 0; i < devices.GetN (); i++)
    {
      netDevice = StaticCast<WifiNetDevice> (devices.Get (i));
      map_Mac2ID[netDevice->GetMac ()->GetAddress ()] = netDevice->GetNode ()->GetId ();
    }

  /* Connect DMG PCP/AP and DMG STA Traces */
  Ptr<WifiNetDevice> wifiNetDevice;
  Ptr<DmgApWifiMac> dmgApWifiMac;
  Ptr<DmgStaWifiMac> dmgStaWifiMac;
  Ptr<WifiRemoteStationManager> apRemoteStationManager;
  uint32_t nodeId;

  /* Get SLS Traces */
  AsciiTraceHelper ascii;
  Ptr<OutputStreamWrapper> outputSlsPhase = CreateSlsTraceStream ("slsResults" + arrayConfig);

  /* Get SNR Traces */
  Ptr<OutputStreamWrapper> snrStream = ascii.CreateFileStream ("snrValues.csv");
  *snrStream->GetStream () << "TIME,SRC,DST,SNR" << std::endl;

  for (uint32_t i = 0; i < apDevices.GetN (); i++)
    {
      /* DMG STA Traces */
      wifiNetDevice = StaticCast<WifiNetDevice> (staDevices.Get (i));
      dmgStaWifiMac = StaticCast<DmgStaWifiMac> (wifiNetDevice->GetMac ());
      dmgStaWifiMac->TraceConnectWithoutContext ("Assoc", MakeBoundCallback (&StationAssoicated, staWifiNodes.Get (i), dmgStaWifiMac));
      dmgStaWifiMac->TraceConnectWithoutContext ("DeAssoc", MakeBoundCallback (&StationDeassoicated, staWifiNodes.Get (i), dmgStaWifiMac));
      Ptr<SLS_PARAMETERS> parametersSta = Create<SLS_PARAMETERS> ();
      nodeId = wifiNetDevice->GetNode ()->GetId ();
      parametersSta->srcNodeID = nodeId;
      parametersSta->wifiMac = dmgStaWifiMac;
      dmgStaWifiMac->TraceConnectWithoutContext ("SLSCompleted", MakeBoundCallback (&SLSCompleted,  outputSlsPhase, parametersSta));

      /* DMG PCP/AP Traces */
      wifiNetDevice = StaticCast<WifiNetDevice> (apDevices.Get (i));
      dmgApWifiMac = StaticCast<DmgApWifiMac> (wifiNetDevice->GetMac ());
      apRemoteStationManager = wifiNetDevice->GetRemoteStationManager ();
      Ptr<SLS_PARAMETERS> parametersAp = Create<SLS_PARAMETERS> ();
      nodeId = wifiNetDevice->GetNode ()->GetId ();
      parametersAp->srcNodeID = nodeId;
      parametersAp->wifiMac = dmgStaWifiMac;
      dmgApWifiMac->TraceConnectWithoutContext ("SLSCompleted", MakeBoundCallback (&SLSCompleted, outputSlsPhase,  parametersAp));
      dmgApWifiMac->TraceConnectWithoutContext ("DTIStarted", MakeBoundCallback (&DataTransmissionIntervalStarted,
                                                                                 dmgApWifiMac, dmgStaWifiMac));
      apRemoteStationManager->TraceConnectWithoutContext ("MacRxOK", MakeBoundCallback (&MacRxOk, dmgApWifiMac, snrStream));

      biCounter[dmgApWifiMac->GetAddress ()] = 0;
    }

  /* Enable Traces */
  if (pcapTracing)
    {
      wifiPhy.SetPcapDataLinkType (YansWifiPhyHelper::DLT_IEEE802_11_RADIO);
      wifiPhy.SetSnapshotLength (snapshotLength);
      wifiPhy.EnablePcap ("Traces/AccessPoint", apDevices, false);
      wifiPhy.EnablePcap ("Traces/STA", staDevices, false);
    }

  /* Install FlowMonitor on all nodes */
  FlowMonitorHelper flowmon;
  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();

  /* Print Output */
  if (!csv)
    {
      std::cout << "Application Layer Throughput per Communicating Pair [Mbps]" << std::endl;
      std::cout << std::left << std::setw (12) << "Time [s]";
      string columnName;
      for (uint8_t i = 0; i < communicationPairList.size (); i++)
        {
          columnName = "Pair (" + std::to_string (i + 1) + ")";
          std::cout << std::left << std::setw (12) << columnName;
        }
      std::cout << std::left << std::setw (12) << "Total"
                << std::left << std::setw (12) << "Trace Index" << std::endl;
    }

  /* Schedule Throughput Calulcations */
  Simulator::Schedule (Seconds (0.1), &CalculateThroughput);

  Simulator::Stop (Seconds (simulationTime + 0.101));
  Simulator::Run ();
  Simulator::Destroy ();

  if (!csv)
    {
      PrintApplicationLayerAndFlowMonitorStatistics (flowmon, monitor, communicationPairList,
                                                     applicationType, simulationTime - 0.1);
    }

  return 0;
}
